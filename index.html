<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>HtmlImgLabelizer</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.19.0/js/md5.min.js"></script>
    <style>
        .image-container {
            display: flex;
            align-items: center;
            margin: 20px 0;
        }

        .image-wrapper {
            position: relative;
            display: inline-block;
        }

        .image-info {
            margin-left: 20px;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div id="app">
        <div>
            <h1>HtmlImgLabelizer</h1>
            <input type="file" multiple @change="onFileBtnFilesChanged">
            <input type="button" value="Export yolo labels" @click="exportZip">
            <hr>

            <div v-for="(img, index) in images" :key="index" class="image-container">
                <div class="image-wrapper">

                    <canvas :ref="'canvasResult'+index" :width="img.width" :height="img.height"></canvas>

                    <canvas :ref="'canvasPreview'+index" :width="img.width" :height="img.height"
                        style="position: absolute; top:0; left:0;" @mousedown="startPreview($event, index)"></canvas>
                </div>
                <div class="image-info">
                    <div>{{ img.name }}</div>
                    <input type="button" value="Reset Labels" @click="resetLabels(index)">
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, nextTick } = Vue;

        createApp({
            data() {
                return {
                    images: [],   // {name, width, height, md5, file, labels:[], imgElement}
                    currentLabelName: null,
                    previewImageIdx: null,
                    previewBox: null,  // { index, x0, y0, x1, y1, rect, canvas }
                    classes: ["apple", "banana"],
                    colors: [
                        "red",
                        "orange",
                        "yellow",
                        "green",
                        "blue",
                        "indigo",
                        "violet"
                    ]
                }
            },
            methods: {
                onFileBtnFilesChanged(event) {
                    const files = event.target.files;
                    this.addImages(files);
                },
                addImages(files) {
                    for (let file of files) {
                        if (!file.type.startsWith("image/")) continue;
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                const md5sum = md5(e.target.result);
                                this.images.push({
                                    name: file.name,
                                    width: img.width,
                                    height: img.height,
                                    md5: md5sum,
                                    file: file,
                                    labels: [],
                                    imgElement: img
                                });
                                nextTick(() => this.drawLabels(this.images.length - 1));
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                },
                drawLabels(index) {
                    const canvas = this.$refs["canvasResult" + index][0];
                    const ctx = canvas.getContext("2d");
                    const img = this.images[index].imgElement;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);

                    for (let label of this.images[index].labels) {
                        ctx.strokeStyle = this.getLabelColor(label.name);
                        ctx.lineWidth = 2;

                        const x = Math.min(label.x0, label.x1);
                        const y = Math.min(label.y0, label.y1);
                        const w = Math.abs(label.x1 - label.x0);
                        const h = Math.abs(label.y1 - label.y0);

                        ctx.strokeRect(x, y, w, h);

                        ctx.fillStyle = this.getLabelColor(label.name);
                        ctx.font = "16px Arial";
                        ctx.fillText(label.name, x + 2, y + 16);
                    }
                },
                getLabelColor(labelName) {
                    return this.colors[this.classes.indexOf(labelName) % this.colors.length];
                },
                drawPreview(index, box) {
                    const canvas = this.$refs["canvasPreview" + index][0];
                    const ctx = canvas.getContext("2d");

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (!box || !this.currentLabelName) return;

                    const { x0, y0, x1, y1 } = box;
                    const x = Math.min(x0, x1);
                    const y = Math.min(y0, y1);
                    const w = Math.abs(x1 - x0);
                    const h = Math.abs(y1 - y0);

                    const color = this.getLabelColor(this.currentLabelName);

                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([6, 3]);
                    ctx.strokeRect(x, y, w, h);
                    ctx.setLineDash([]);
                },
                startPreview(event, index) {
                    if (!this.currentLabelName) return;
                    this.previewImageIdx = index;

                    const canvas = this.$refs["canvasPreview" + index][0];
                    const rect = canvas.getBoundingClientRect();

                    const x0 = Math.floor(event.clientX - rect.left);
                    const y0 = Math.floor(event.clientY - rect.top);

                    this.previewBox = { index, x0, y0, x1: x0, y1: y0, rect, canvas };
                },
                updatePreview(event) {
                    if (!this.currentLabelName) return;
                    if (!this.previewBox || !(this.previewImageIdx >= 0)) return;

                    const { rect, canvas } = this.previewBox;

                    let x = event.clientX - rect.left;
                    let y = event.clientY - rect.top;

                    x = Math.max(0, Math.min(Math.floor(x), canvas.width));
                    y = Math.max(0, Math.min(Math.floor(y), canvas.height));

                    this.previewBox.x1 = x;
                    this.previewBox.y1 = y;

                    this.drawPreview(this.previewImageIdx, this.previewBox);
                },
                endDraw(event) {
                    if (!this.previewBox || !this.currentLabelName || !(this.previewImageIdx >= 0)) return;

                    const { x0, y0, x1, y1 } = this.previewBox;

                    const minX = Math.min(x0, x1);
                    const minY = Math.min(y0, y1);
                    const maxX = Math.max(x0, x1);
                    const maxY = Math.max(y0, y1);

                    this.addLabel(this.previewImageIdx, this.currentLabelName, minX, minY, maxX, maxY);
                    this.drawLabels(this.previewImageIdx);
                    this.drawPreview(this.previewImageIdx, null);

                    this.previewBox = null;
                },
                addLabel(index, name, x0, y0, x1, y1) {
                    this.images[index].labels.push({ name, x0, y0, x1, y1 });
                },
                resetLabels(index) {
                    this.images[index].labels = [];
                    this.drawLabels(index);
                },
                handleKey(event) {
                    if (event.key === "1") this.currentLabelName = "apple";
                    if (event.key === "2") this.currentLabelName = "banana";
                },
                async exportZip() {
                    const zip = new JSZip();
                    const dataJson = [];
                    for (let img of this.images) {
                        const txtLines = [];
                        for (let label of img.labels) {
                            const x_center = ((label.x0 + label.x1) / 2) / img.width;
                            const y_center = ((label.y0 + label.y1) / 2) / img.height;
                            const w = Math.abs(label.x1 - label.x0) / img.width;
                            const h = Math.abs(label.y1 - label.y0) / img.height;
                            const classId = this.classes.indexOf(label.name);
                            txtLines.push(`${classId} ${x_center.toFixed(6)} ${y_center.toFixed(6)} ${w.toFixed(6)} ${h.toFixed(6)}`);
                        }
                        zip.file(img.name.replace(/\.[^/.]+$/, ".txt"), txtLines.join("\n"));
                        dataJson.push({
                            imgName: img.name,
                            width: img.width,
                            height: img.height,
                            md5: img.md5,
                            labels: img.labels
                        });
                    }
                    zip.file("data.json", JSON.stringify(dataJson, null, 2));
                    const content = await zip.generateAsync({ type: "blob" });
                    const a = document.createElement("a");
                    a.href = URL.createObjectURL(content);
                    a.download = "labels.zip";
                    a.click();
                }
            },
            mounted() {
                window.addEventListener("keydown", this.handleKey);
                window.addEventListener("mousemove", this.updatePreview);
                window.addEventListener("mouseup", this.endDraw);
            },
            beforeUnmount() {
                window.removeEventListener("keydown", this.handleKey);
                window.removeEventListener("mousemove", this.updatePreview);
                window.removeEventListener("mouseup", this.endDraw);
            }
        }).mount("#app");
    </script>
</body>

</html>